package com.cyp.chx.rcenter.hessian.code;

import io.netty.buffer.ByteBuf;

import java.io.IOException;
import java.io.InputStream;

public class HessianInputStream extends InputStream {

	private final ByteBuf buffer;
    private final int startIndex;
	private final int endIndex;

	public HessianInputStream(ByteBuf buffer) {
		this(buffer, buffer.readableBytes());
	}

	public HessianInputStream(ByteBuf buffer, int length) {
		if (buffer == null) {
			throw new NullPointerException("buffer");
		}
		if (length < 0) {
			throw new IllegalArgumentException("length: " + length);
		}
		if (length > buffer.readableBytes()) {
			throw new IndexOutOfBoundsException();
		}

		this.buffer = buffer;
		startIndex = buffer.readerIndex();
		endIndex = startIndex + length;
		buffer.markReaderIndex();
	}

	public int readBytes() {
		return buffer.readerIndex() - startIndex;
	}

	@Override
	public int available() throws IOException {
		return endIndex - buffer.readerIndex();
	}

	@Override
	public void mark(int readlimit) {
		buffer.markReaderIndex();
	}

	@Override
	public boolean markSupported() {
		return true;
	}

	@Override
	public int read() throws IOException {
		if (!buffer.isReadable()) {
			return -1;
		}
		return buffer.readByte() & 0xff;
	}

	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		int available = available();
		if (available == 0) {
			return -1;
		}

		len = Math.min(available, len);
		buffer.readBytes(b, off, len);
		return len;
	}

	@Override
	public void reset() throws IOException {
		buffer.resetReaderIndex();
	}

	@Override
	public long skip(long n) throws IOException {
		if (n > Integer.MAX_VALUE) {
			return skipBytes(Integer.MAX_VALUE);
		} else {
			return skipBytes((int) n);
		}
	}

	private int skipBytes(int n) throws IOException {
		int nBytes = Math.min(available(), n);
		buffer.skipBytes(nBytes);
		return nBytes;
	}

}